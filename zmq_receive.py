import zmq
import json
from io import StringIO
import cv2
import numpy as np
from pathlib import Path
import os
import base64
import argparse

parser = argparse.ArgumentParser(description="Visualize the output generated by cvedia-rt through ZMQ")
parser.add_argument(
    '--ip', type=str,required=True, default="192.168.1.96",
    help='Device ip')
parser.add_argument(
    '--port', type=str,required=False, default="5555",
    help='Port where zmq is connected to')

parser.add_argument(
    '--video-dir', type=Path,required=False, default=None,
    help='Path to directory with offline videos')

args = parser.parse_args()

device_ip = args.ip
port = args.port
video_base_dir = args.video_dir

imported_frames = {}

frames_output_path = "output/frames"
profiler_stats_output_path = "output/profiler"

write_frames_to_disk = False

os.makedirs(frames_output_path,exist_ok=True)
os.makedirs(profiler_stats_output_path,exist_ok=True)

def import_frames(path_str, video_base_dir):

    if path_str in imported_frames:
        return imported_frames[path_str]

    if video_base_dir is not None:
        path_str = os.path.join(video_base_dir, Path(path_str).name)
        
    frames = []

    print(f"Importing images from {path_str}")

    path = Path(path_str)
    if path.exists():
        for p in path.iterdir():
            if p.suffix.lower() in [".jpg", ".jpeg", ".png"]:
                frames.append(str(p))
    frames.sort()
    imported_frames[path_str] = frames
    return frames

def coords_to_int(coords):
    return list(map(lambda a: list(map(int, a)), coords))

def process_data(frame, meta):
    lines = meta["metadata"]["lines"]
    polylines = meta["metadata"]["polylines"]
    rectangles = meta["metadata"]["rectangles"]
    circles = meta["metadata"]["circles"]
    texts = meta["metadata"]["texts"]
    step = meta["step"]

    for line in lines:
        start = list(map(int, line["srcPt"]))
        end = list(map(int, line["dstPt"]))
        color = list(map(int, line["color"]))
        frame = cv2.line(frame, start, end, color, 2)
    
    for polyline in polylines:
        shape = coords_to_int(polyline["shape"])
        color = list(map(int, polyline["color"]))
        rect_frame = frame.copy()
        rect_frame = cv2.fillPoly(rect_frame, [np.array(shape, np.int32)], color)
        alpha = 0.5
        frame = cv2.addWeighted(frame, alpha, rect_frame, 1 - alpha, 0)

    for rectangle in rectangles:
        x = int(rectangle["x"])
        y = int(rectangle["y"])
        width = int(rectangle["width"])
        height = int(rectangle["height"])
        color = list(map(int, rectangle["color"]))
        thickness = int(rectangle["thickness"])

        frame = cv2.rectangle(frame, (x, y),(x+width, y+height), color, thickness)
        
    for circle in circles:
        x = int(circle["centerPt"][0])
        y = int(circle["centerPt"][1])
        radius = int(circle["radius"])
        color = list(map(int, circle["color"]))
        frame = cv2.circle(frame,(x,y), radius, color, 2)
        
    for text in texts:
        x = int(text["srcPt"][0])
        y = int(text["srcPt"][1])
        str = text["text"]
        color = list(map(int, text["color"]))
        fontscale = text["fontscale"]
        thickness = int(text["thickness"])
        fontface = int(text["fontface"])

        frame = cv2.putText(frame, str, (x,y), fontface, fontscale, color, thickness)

    frame = cv2.putText(frame, f"{int(step)} ms", (10,20), 1, 1.0, (255,255,255), 1)
    frame = cv2.putText(frame, f"{(meta['frame'] - 1)/30:.2f} s", (10,40), 1, 1.0, (255,255,255), 1)

    return frame

def process_profiler_stats(payload):

    if "perfCounters" in payload:
        instanceName = payload["instanceName"]
        perfCounters = payload["perfCounters"]

        outputFilePath = os.path.join(profiler_stats_output_path,instanceName+".json")

        with open(outputFilePath, 'w') as outfile:
            json.dump(perfCounters, outfile, indent=4)

def main(ip : str, port : str):
    context = zmq.Context()
    print("Connecting …")
    socket = context.socket(zmq.PULL)
    socket.connect(f"tcp://{ip}:{port}")

    print("Running the loop …")
    frameIdx = 0
    while True:
        message = socket.recv()
        io = StringIO(message.decode("utf-8"))
        js = json.load(io)


        if "image" in js:
            data = np.frombuffer(base64.b64decode(np.array(js["image"]).tobytes()), np.uint8)
            frame = cv2.imdecode(data, cv2.IMREAD_UNCHANGED)
            if len(frame.shape) == 2 or frame.shape[2] == 1:
                fr_size = (*frame.shape[:2], 3)
                img2 = np.zeros(fr_size, np.uint8)
                img2[:,:,0] = frame
                img2[:,:,1] = frame
                img2[:,:,2] = frame
                frame = img2
        else:
            print(js)
            source = js["source"]
            source = source[source.index("videos"):]
            frames = import_frames(source, video_base_dir)
            frame = cv2.imread(frames[int(js["frame"]-1)])

        frame = process_data(frame, js)
        process_profiler_stats(js)

        if write_frames_to_disk:
            cv2.imwrite(os.path.join(frames_output_path,f"img_{frameIdx:03d}.jpg"),frame)

        cv2.imshow("Display window", frame)

        cv2.waitKey(10)

        frameIdx += 1

main(device_ip, port)
